<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>--jaewdoy--</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="--jaewdoy--">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="--jaewdoy--">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="--jaewdoy--" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">--jaewdoy--</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Android-Java层逆向" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/16/Android-Java%E5%B1%82%E9%80%86%E5%90%91/" class="article-date">
  <time class="dt-published" datetime="2025-10-16T15:07:48.000Z" itemprop="datePublished">2025-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/16/Android-Java%E5%B1%82%E9%80%86%E5%90%91/">Android - Java层逆向</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="关于apk文件的基础知识"><a href="#关于apk文件的基础知识" class="headerlink" title="关于apk文件的基础知识"></a>关于apk文件的基础知识</h3><h4 id="apk的本质"><a href="#apk的本质" class="headerlink" title="apk的本质"></a>apk的本质</h4><p>APK 是 Android Application Package 的缩写，本质上是一个压缩包文件，基于 ZIP 格式归档。可以直接将 <code>.apk</code> 文件重命名为 <code>.zip</code>，然后用解压软件打开查看内部结构。</p>
<h4 id="apk的内部结构"><a href="#apk的内部结构" class="headerlink" title="apk的内部结构"></a>apk的内部结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一个完整的APK文件结构</span><br><span class="line">├── AndroidManifest.xml          # 【核心】应用配置清单</span><br><span class="line">├── classes.dex                  # 【核心】Java代码编译后的字节码</span><br><span class="line">├── resources.arsc               # 【核心】编译后的资源索引表</span><br><span class="line">├── res/                         # 资源文件目录</span><br><span class="line">│   ├── drawable/                # 图片资源（PNG, JPG等）</span><br><span class="line">│   ├── layout/                  # 界面布局文件（XML）</span><br><span class="line">│   ├── values/                  # 数值资源（字符串、颜色、尺寸等）</span><br><span class="line">│   └── ...                      # 其他资源类型</span><br><span class="line">├── assets/                      # 原始资源文件目录</span><br><span class="line">├── lib/                         # 原生库目录（.so文件）</span><br><span class="line">│   ├── armeabi-v7a/             # 32位ARM架构库</span><br><span class="line">│   ├── arm64-v8a/               # 64位ARM架构库</span><br><span class="line">│   └── x86/                     # x86架构库</span><br><span class="line">├── META-INF/                    # 应用签名信息</span><br><span class="line">│   ├── MANIFEST.MF              # 文件清单</span><br><span class="line">│   ├── CERT.SF                  # 签名文件</span><br><span class="line">│   └── CERT.RSA                 # 签名证书</span><br><span class="line">└── kotlin/                      # Kotlin运行时库（如果使用了Kotlin）</span><br></pre></td></tr></table></figure>

<h5 id="Java层逆向需关注："><a href="#Java层逆向需关注：" class="headerlink" title="Java层逆向需关注："></a>Java层逆向需关注：</h5><ul>
<li><code>classes.dex</code> - 代码核心</li>
</ul>
<p>这是反编译的主要目标，包含应用的所有业务逻辑。</p>
<ul>
<li><code>AndroidManifest.xml</code> - 应用蓝图</li>
</ul>
<p>声明应用的基本信息、权限、组件等，可找到应用入口点，了解应用结构。</p>
<ul>
<li><code>resources.arsc</code> + <code>res/</code> - 资源宝库</li>
</ul>
<p>存储所有字符串、布局、图片等资源，可查找硬编码信息，分析界面布局</p>
<h3 id="Java层逆向工具"><a href="#Java层逆向工具" class="headerlink" title="Java层逆向工具"></a>Java层逆向工具</h3><h4 id="jadx"><a href="#jadx" class="headerlink" title="jadx"></a>jadx</h4><ul>
<li>功能：直接将 APK 反编译成可读的 <strong>Java 代码</strong></li>
<li>使用：<code>jadx-gui app.apk</code></li>
</ul>
<h4 id="Apktool"><a href="#Apktool" class="headerlink" title="Apktool"></a>Apktool</h4><ul>
<li><p>功能：解包 APK 得到 <strong>Smali 代码</strong>和资源文件</p>
</li>
<li><p>优点：可以修改后重新打包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 解包</span><br><span class="line">apktool d app.apk -o output_dir</span><br><span class="line"># 打包</span><br><span class="line">apktool b output_dir -o new_app.apk</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>jadx为静态观察，apktool为动态修改，二者相辅相成。</p>
</blockquote>
<h2 id="smali语言"><a href="#smali语言" class="headerlink" title="smali语言"></a>smali语言</h2><p>理解：</p>
<p>Smali 语言是 Java 语言和 Android 虚拟机（Dalvik&#x2F;ART）机器指令之间的<strong>中间语言</strong>，其地位和作用非常类似于 x86 架构下的汇编语言。</p>
<h3 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pinksofts/article/details/132244543">smali语法从入门到精通-CSDN博客</a></p>
<h2 id="dex文件与class文件"><a href="#dex文件与class文件" class="headerlink" title="dex文件与class文件"></a>dex文件与class文件</h2><h3 id="dalvik和jvm"><a href="#dalvik和jvm" class="headerlink" title="dalvik和jvm"></a>dalvik和jvm</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>JVM 是 Java Virtual Machine 的缩写，它是为<strong>台式电脑和服务器</strong>设计的。</p>
<p>原理：</p>
<p><img src="C:/Users/二、、、、/AppData/Roaming/Typora/typora-user-images/image-20251016225850167.png" alt="image-20251016225850167"></p>
<p>特点：</p>
<ul>
<li>平台独立：一次编译，到处运行（Write Once, Run Anywhere）</li>
<li><strong>基于栈</strong>：使用操作数栈来执行指令</li>
<li>内存消耗大：为性能优化的同时占用较多资源</li>
<li>单类单文件：每个 Java 类编译成一个单独的 <code>.class</code> 文件</li>
</ul>
<h4 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h4><p>Dalvik 是 Android 系统早期使用的虚拟机，专门为<strong>手机等移动设备</strong>设计。</p>
<p><img src="C:/Users/二、、、、/AppData/Roaming/Typora/typora-user-images/image-20251016230100953.png" alt="image-20251016230100953"></p>
<p>特点：</p>
<ul>
<li><strong>基于寄存器</strong>：使用CPU寄存器来执行指令</li>
<li>整合优化：将所有 <code>.class</code> 文件合并成一个 <code>.dex</code> 文件</li>
<li>内存优化：为资源受限的移动设备专门设计</li>
<li>省电高效：在性能和功耗间取得平衡</li>
</ul>
<h3 id="dex文件结构"><a href="#dex文件结构" class="headerlink" title="dex文件结构"></a>dex文件结构</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66800634">Android逆向笔记 —— DEX 文件格式解析 - 知乎</a></p>
<h3 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66800054">Class 文件格式详解 - 知乎</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/16/Android-Java%E5%B1%82%E9%80%86%E5%90%91/" data-id="cmgtk5wp80000t4gcaa05di7a" data-title="Android - Java层逆向" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-angr分析框架" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/16/angr%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6/" class="article-date">
  <time class="dt-published" datetime="2025-10-16T10:42:06.000Z" itemprop="datePublished">2025-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/16/angr%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6/">angr分析框架</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是angr"><a href="#什么是angr" class="headerlink" title="什么是angr"></a>什么是angr</h2><p>angr是一个基于Python的二进制分析框架。</p>
<h3 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h3><ol>
<li><p>加载与解析各种格式的二进制文件，理解不同CPU架构的指令集。</p>
<blockquote>
<p>通过 <code>Project</code> 类实现。</p>
</blockquote>
</li>
<li><p>将机器指令翻译成中间语言（VEX IR）。这样一来，一套分析引擎可以分析所有架构。无论原始程序是x86还是ARM，在angr内部都变成了同一种“语言”来处理。</p>
</li>
<li><p><strong>符号执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通执行：x = 5 + 1 -&gt; 结果是 6 。</span><br><span class="line">符号执行：x = 5 + input -&gt; 结果不是一个具体数字，而是一个表达式 5 + input。</span><br></pre></td></tr></table></figure>

<!--这里的 input 是一个符号，代表任何可能的值。-->

<p>通过这种方式，angr可以<strong>同时探索程序所有可能的分支路径</strong>。</p>
</li>
<li><p>约束求解</p>
<p>当angr在符号执行过程中遇到条件判断时，它会为每条路径生成一个<strong>约束条件</strong>。</p>
<p>angr内置了一个约束求解器，这使它能够自动生成触发特定程序状态的输入。</p>
</li>
</ol>
<h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>安装 angr</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> pip install angr</span><br></pre></td></tr></table></figure>

<ol>
<li>安装 angr-utils</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> angr-dev</span><br><span class="line"><span class="variable">$cd</span> angr-dev</span><br><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/axt/bingraphvis</span><br><span class="line"><span class="variable">$pip</span> install -e ./bingraphvis</span><br><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/axt/angr-utils</span><br><span class="line"><span class="variable">$pip</span> install -e ./angr-utils</span><br></pre></td></tr></table></figure>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="angr的一些类和方法"><a href="#angr的一些类和方法" class="headerlink" title="angr的一些类和方法"></a>angr的一些类和方法</h4><h5 id="project"><a href="#project" class="headerlink" title="project"></a>project</h5><p>project 类是 angr 的主类，也是angr的开始，通过<strong>初始化 project 类</strong>加载二进制文件，提供分析所需的各种接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">p = angr.Project(<span class="string">&#x27;file_path&#x27;</span>)            <span class="comment">#传入二进制文件的路径</span></span><br></pre></td></tr></table></figure>

<p>其他可选参数：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto_load_libs</td>
<td align="left">是否自动加载程序的依赖（少加载无关结果的库可以提升angr效率）</td>
<td align="left">auto_load_libs　&#x3D; False</td>
</tr>
<tr>
<td align="left">skip_libs</td>
<td align="left">希望避免加载的库</td>
<td align="left">skip_libs &#x3D; 库名</td>
</tr>
<tr>
<td align="left">except_missing_libs</td>
<td align="left">无法解析库时是否抛出异常</td>
<td align="left">True &#x2F; False</td>
</tr>
<tr>
<td align="left">force_load_libs</td>
<td align="left">强制加载的库</td>
<td align="left">force_load_libs &#x3D; 库名</td>
</tr>
<tr>
<td align="left">ld_path</td>
<td align="left">共享库的优先搜索路径</td>
<td align="left">ld_path &#x3D; 路径名</td>
</tr>
</tbody></table>
<p>project 类的方法和属性：</p>
<ul>
<li>p.arch : 文件架构</li>
<li>hex(p.entry) ： 程序入口点</li>
<li>p.filename ： 加载的文件名</li>
<li>p.arch.bits ： 字长（32位 &#x2F; 64位）</li>
<li>p.arch.memory_endness ： 大小端</li>
</ul>
<h5 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h5><p>project只是加载二进制文件，实际是对simstate对象操作。</p>
<p>simstate对象是程序的状态，包含运行时的一切信息，例如寄存器、内存值、文件系统、<strong>符号变量</strong></p>
<p>创建状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = p.factory.entry_state()</span><br></pre></td></tr></table></figure>

<p>预设状态：</p>
<p>前两个比较常用，blank_state用于跳过一些极大降低angr效率的指令。</p>
<p>初始时RAX的数据类型都是bit vector。</p>
<blockquote>
<p><strong>BitVector（位向量）</strong> 是一个固定长度的二进制位序列，用于表示整数值。</p>
<ul>
<li><strong>长度</strong>：8位、16位、32位、64位等</li>
<li><strong>值</strong>：可以是具体值，也可以是符号值</li>
</ul>
</blockquote>
<blockquote>
<p>RAX：x86累加器寄存器</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">预设状态方式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">entry_state</td>
<td align="left">初始化状态为程序运行到程序入口点处的状态</td>
</tr>
<tr>
<td align="left">blank_state(addr&#x3D;)</td>
<td align="left"><strong>大多数数据都没有初始化</strong>，状态中下一条指令为addr处的指令</td>
</tr>
<tr>
<td align="left">full_init_state</td>
<td align="left">共享库和预定义内容已经加载完毕，例如刚加载完共享库</td>
</tr>
<tr>
<td align="left">call_state</td>
<td align="left">准备调用函数的状态</td>
</tr>
</tbody></table>
<p>factory 类的方法：</p>
<ul>
<li>state.regs：寄存器访问接口</li>
</ul>
<h5 id="simgr"><a href="#simgr" class="headerlink" title="simgr"></a>simgr</h5><h6 id="一、认识simgr"><a href="#一、认识simgr" class="headerlink" title="一、认识simgr"></a>一、认识simgr</h6><p>超级简单比喻：</p>
<p>想象 <code>simgr</code> 是一个公交车站的总调度系统：</p>
<ul>
<li>公交车 &#x3D; <code>state</code>（程序状态）</li>
<li>公交车站 &#x3D; <code>simgr</code>（模拟管理器）</li>
<li>不同的停车区 &#x3D; <code>stash</code>（状态集合）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建公交车站，并安排几辆公交车进站</span><br><span class="line">state = p.factory.entry_state()</span><br><span class="line">simgr = p.factory.simgr(state)  # 创建车站，初始有一辆公交车</span><br></pre></td></tr></table></figure>

<p><code>stash</code> - 某种状态的state</p>
<table>
<thead>
<tr>
<th align="left">stash 名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>active</code></strong></td>
<td align="left">当前正在探索的状态</td>
</tr>
<tr>
<td align="left"><strong><code>deadended</code></strong></td>
<td align="left">执行完成的状态</td>
</tr>
<tr>
<td align="left"><strong><code>found</code></strong></td>
<td align="left">到达目标地址的状态</td>
</tr>
<tr>
<td align="left"><strong><code>avoided</code></strong></td>
<td align="left">避开指定地址的状态</td>
</tr>
</tbody></table>
<p>simgr,stash,state的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">simgr (状态管理器)</span><br><span class="line">│</span><br><span class="line">├── active stash (活跃状态集合)</span><br><span class="line">│   ├── state 1</span><br><span class="line">│   ├── state 2</span><br><span class="line">│   └── state 3</span><br><span class="line">│</span><br><span class="line">├── found stash (找到目标状态集合) </span><br><span class="line">│   └── state 4</span><br><span class="line">│</span><br><span class="line">└── deadended stash (终止状态集合)</span><br><span class="line">    ├── state 5</span><br><span class="line">    └── state 6</span><br></pre></td></tr></table></figure>

<h6 id="二、例子"><a href="#二、例子" class="headerlink" title="二、例子"></a>二、例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import angr</span><br><span class="line"></span><br><span class="line"># 创建程序和初始状态</span><br><span class="line">p = angr.Project(&#x27;/bin/true&#x27;, auto_load_libs=False)</span><br><span class="line">state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line"># 创建simgr</span><br><span class="line">simgr = p.factory.simgr(state)</span><br><span class="line"></span><br><span class="line">print(&quot;=== 初始状态 ===&quot;)</span><br><span class="line">print(f&quot;active 停车区有 &#123;len(simgr.active)&#125; 辆公交车&quot;)</span><br><span class="line">print(f&quot;deadended 停车区有 &#123;len(simgr.deadended)&#125; 辆公交车&quot;)</span><br></pre></td></tr></table></figure>

<p>输出可能是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== 初始状态 ===</span><br><span class="line">active 停车区有 1 辆公交车</span><br><span class="line">deadended 停车区有 0 辆公交车</span><br></pre></td></tr></table></figure>

<h6 id="四、stash-的访问方式"><a href="#四、stash-的访问方式" class="headerlink" title="四、stash 的访问方式"></a>四、stash 的访问方式</h6><ol>
<li>直接访问列表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看 active 停车区有多少辆公交车</span><br><span class="line">print(f&quot;有 &#123;len(simgr.active)&#125; 辆公交车在运行&quot;)</span><br><span class="line"></span><br><span class="line"># 查看第一辆公交车的状态</span><br><span class="line">if len(simgr.active) &gt; 0:</span><br><span class="line">    first_bus = simgr.active[0]  # 第一辆公交车</span><br><span class="line">    print(f&quot;第一辆公交车的RAX: &#123;first_bus.regs.rax&#125;&quot;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快捷访问方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># one_active - 获取第一辆正在运行的公交车</span><br><span class="line">bus = simgr.one_active</span><br><span class="line">print(f&quot;当前主要公交车: &#123;bus&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># one_found - 获取第一辆找到目标的公交车（如果有的话）</span><br><span class="line">if simgr.found:</span><br><span class="line">    successful_bus = simgr.one_found</span><br><span class="line">    print(f&quot;成功到达的公交车: &#123;successful_bus&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h6 id="五、mp-前缀的作用"><a href="#五、mp-前缀的作用" class="headerlink" title="五、mp_ 前缀的作用"></a>五、<code>mp_</code> 前缀的作用</h6><p><code>mp_</code> 开头的 stash 用于同时操作多个状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 同时读取所有active公交车的RAX值</span><br><span class="line">all_rax_values = simgr.mp_active.regs.rax</span><br><span class="line">print(f&quot;所有公交车的RAX: &#123;all_rax_values&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 这相当于：</span><br><span class="line"># rax_list = [bus.regs.rax for bus in simgr.active]</span><br></pre></td></tr></table></figure>

<h5 id="eval方法"><a href="#eval方法" class="headerlink" title="eval方法"></a>eval方法</h5><ul>
<li><code>solver.eval(expression)</code> 将会解出一个可行解</li>
<li><code>solver.eval_one(expression)</code>将会给出一个表达式的可行解，若有多个可行解，则抛出异常。</li>
<li><code>solver.eval_upto(expression, n)</code>将会给出最多n个可行解，如果不足n个就给出所有的可行解。</li>
<li><code>solver.eval_exact(expression, n)</code>将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。</li>
<li><code>solver.min(expression)</code>将会给出最小可行解</li>
<li><code>solver.max(expression)</code>将会给出最大可行解</li>
</ul>
<p>ex.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#创建符号变量</span><br><span class="line">x = claripy.BVS(&#x27;x&#x27;, 32)</span><br><span class="line"></span><br><span class="line">#添加约束</span><br><span class="line">state.solver.add(x &gt; 10)</span><br><span class="line">state.solver.add(x &lt; 20)</span><br><span class="line"></span><br><span class="line">#求解具体值</span><br><span class="line">solution = state.solver.eval(x)  # 返回一个满足约束的具体整数</span><br></pre></td></tr></table></figure>



<h2 id="CTF实例"><a href="#CTF实例" class="headerlink" title="CTF实例"></a>CTF实例</h2><h4 id="1-一个最简单的假设"><a href="#1-一个最简单的假设" class="headerlink" title="1.一个最简单的假设"></a>1.一个最简单的假设</h4><p>假设有一个CTF程序，要求输入一个密码，正确则打印 <code>&quot;Good Job!&quot;</code>，错误则打印 <code>&quot;Try again!&quot;</code>。</p>
<p>传统逆向：用IDA等工具反汇编，理解校验逻辑，然后手动推导出密码。</p>
<p><strong>使用angr</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line"></span><br><span class="line"># 1. 加载二进制文件</span><br><span class="line">p = angr.Project(&#x27;ctf_binary&#x27;, auto_load_libs=False)          #auto_load_libs=False：少加                                                               载无关结果的库，提升angr效率</span><br><span class="line"></span><br><span class="line"># 2. 创建一个符号化的“输入”，比如一个100字节的字符串</span><br><span class="line">flag = claripy.BVS(&#x27;flag&#x27;, 100*8)                              # BVS: BitVector Symbol</span><br><span class="line"></span><br><span class="line"># 3. 设置初始状态，将符号输入作为程序的命令行参数或标准输入</span><br><span class="line">state = p.factory.entry_state(args=[&#x27;./ctf_binary&#x27;, flag])</span><br><span class="line"></span><br><span class="line"># 4. 创建模拟管理器，它负责管理所有探索路径</span><br><span class="line">simgr = p.factory.simulation_manager(state)</span><br><span class="line"></span><br><span class="line"># 5. 告诉angr：“去找到打印 ‘Good Job’ 的地方，并避开打印 ‘Try again’ 的地方”</span><br><span class="line">simgr.explore(find=lambda s: b&quot;Good Job&quot; in s.posix.dumps(1),  # 在标准输出中查找</span><br><span class="line">              avoid=lambda s: b&quot;Try again&quot; in s.posix.dumps(1))</span><br><span class="line"></span><br><span class="line"># 6. 如果找到了这样的路径</span><br><span class="line">if simgr.found:</span><br><span class="line">    solution_state = simgr.found[0]</span><br><span class="line">    # 7. 求解：什么样的具体输入能满足到达这里的约束条件？</span><br><span class="line">    solution = solution_state.solver.eval(flag, cast_to=bytes)</span><br><span class="line">    print(f&quot;The flag is: &#123;solution.decode().split(chr(0))[0]&#125;&quot;) # 处理字符串终止符</span><br><span class="line">else:</span><br><span class="line">    print(&quot;No solution found&quot;)</span><br></pre></td></tr></table></figure>



<p>参考：<a target="_blank" rel="noopener" href="https://starrysky1004.github.io/2024/12/17/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/angr-xue-xi-yu-angr-ctf-ti-jie-chi-xu-geng-xin/">angr学习与angr_CTF题解（持续更新） | starrysky</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/16/angr%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6/" data-id="cmgtk5wpd0004t4gc7lut0281" data-title="angr分析框架" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OLLVM混淆与反混淆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/16/OLLVM%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/" class="article-date">
  <time class="dt-published" datetime="2025-10-16T08:33:51.000Z" itemprop="datePublished">2025-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/16/OLLVM%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/">OLLVM混淆与反混淆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://cn-sec.com/archives/4484357.html">OLLVM混淆技术与反混淆实战：从环境搭建到控制流还原 | CN-SEC 中文网</a></p>
<p>补充说明：</p>
<h2 id="OLLVM介绍"><a href="#OLLVM介绍" class="headerlink" title="OLLVM介绍"></a>OLLVM介绍</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>针对LLVM的代码混淆工具，旨在加强逆向的难度</p>
<h3 id="LLVM介绍"><a href="#LLVM介绍" class="headerlink" title="LLVM介绍"></a>LLVM介绍</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ol>
<li><strong>前端（Frontend）</strong><br>负责解析源代码，进行语法 &#x2F; 语义分析，最终生成 LLVM IR。<br>例如：Clang（LLVM 的 C&#x2F;C++ 前端）将 C 代码转换为 IR；rustc（Rust 编译器）也会生成 LLVM IR。</li>
<li><strong>优化器（Optimizer）</strong><br>以 LLVM IR 为输入，通过数百种优化算法（如常量传播、循环展开、死代码消除等）对 IR 进行优化，生成更高效的 IR。<br>这一步是 LLVM 的核心优势：优化逻辑仅需针对 IR 实现一次，即可作用于所有前端支持的语言。</li>
<li><strong>后端（Backend）</strong><br>将优化后的 IR 转换为目标平台的机器码（如 x86、ARM、RISCV 等），并完成寄存器分配、指令选择等平台相关优化。</li>
</ol>
<h2 id="分类——OLLVM的三大功能"><a href="#分类——OLLVM的三大功能" class="headerlink" title="分类——OLLVM的三大功能"></a>分类——OLLVM的三大功能</h2><h3 id="指令替换（Instructions-Substitution）"><a href="#指令替换（Instructions-Substitution）" class="headerlink" title="指令替换（Instructions Substitution）"></a>指令替换（Instructions Substitution）</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>将标准二进制运算符（如加法、减法或布尔运算符）替换为<strong>功能上等效</strong>但更复杂的指令序列。当有多个等效指令序列可用时，随机选择一个。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul>
<li><code>-mllvm -sub</code>：激活指令替换</li>
<li><code>-mllvm -sub_loop=3</code>：如果通道已激活，则在函数上应用 3 次</li>
</ul>
<h3 id="虚假-混淆控制流（Bogus-Control-Flow）"><a href="#虚假-混淆控制流（Bogus-Control-Flow）" class="headerlink" title="虚假&#x2F;混淆控制流（Bogus Control Flow）"></a>虚假&#x2F;混淆控制流（Bogus Control Flow）</h3><p>指令前设置一个永真&#x2F;永假条件，执行判断语句后再执行指令。</p>
<p>标准流程图如下：</p>
<p><img src="/../images/image-20251015223813279.png" alt="image-20251015223813279"></p>
<h4 id="反混淆："><a href="#反混淆：" class="headerlink" title="反混淆："></a>反混淆：</h4><p>将对x,y赋值的地方，使用idapython进行统一的nop。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#去除bcf混淆import ida_xref   #交叉引用操作import ida_idaapiimport ida_bytesimport ida_segmentdef do_patch(ea):if(ida_bytes.get_bytes(ea,1)==b&quot;x8B&quot;):    reg=(ord(ida_bytes.get_bytes(ea+1,1)) &amp; 0b00111000)&gt;&gt;3    ida_bytes.patch_bytes(ea,(0xB8+reg).to_bytes(1,&quot;little&quot;)+b&quot;x00x00x00x00x90x90&quot;)  #patch_bytes(ea, buf)else:print(&quot;error&quot;)seg=ida_segment.get_segm_by_name(&quot;.bss&quot;)start=seg.start_eaend=seg.end_eafor addr in range(start,end,4):  ref=ida_xref.get_first_dref_to(addr)print(hex(ref).center(20,&#x27;-&#x27;))#获取所有的交叉引用while (ref!=ida_idaapi.BADADDR):#BADADDR如果不是无效地址    do_patch(ref)print(&quot;patch at&quot;+hex(ref))&#x27;&#x27;&#x27;    ida_idaapi.ea_t get_next_dref_to ( ida_idaapi.ea_t to,    ida_idaapi.ea_t current )    &#x27;&#x27;&#x27;    ref=ida_xref.get_next_dref_to(addr,ref)print(&quot;-&quot;*20)print(&quot;BCF 去除 finish&quot;)</span><br></pre></td></tr></table></figure>



<h3 id="控制流平展（Control-Flow-Flattening）"><a href="#控制流平展（Control-Flow-Flattening）" class="headerlink" title="控制流平展（Control Flow Flattening）"></a>控制流平展（Control Flow Flattening）</h3><p>以基本块为单位，通过一个主分发器来控制程序的执行流程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/16/OLLVM%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/" data-id="cmgtk5wpb0001t4gcb15ccn4t" data-title="OLLVM混淆与反混淆" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-加密算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T14:30:28.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">&#39;加密算法&#39;</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h2><p>所有字符偏移</p>
<h2 id="Base加密"><a href="#Base加密" class="headerlink" title="Base加密"></a>Base加密</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>基于（Base）64个字符的一种编码方式。使用其编码后的文本只包含<strong>64个ASCII码</strong>字符（偶尔加一个填充字符&#x3D;）</p>
<p>Base64使用到的64个字符：</p>
<p>·<code>A-Z</code> 26个</p>
<p>·<code>a-z</code> 26个</p>
<p>·<code>0-9</code> 10个</p>
<p>·<code>+</code> 1个</p>
<p>·<code>/</code> 1个</p>
<h4 id="编码步骤"><a href="#编码步骤" class="headerlink" title="编码步骤"></a>编码步骤</h4><p>举例：</p>
<ul>
<li>若原始数据长度是3的倍数：</li>
</ul>
<h6 id="若原始数据长度是3的倍数，即8bit×3-24bit，重新划分时6bit为一组，8和6的最小公倍数是24，24bit是3字节，故三个字节为一组时无需补位。"><a href="#若原始数据长度是3的倍数，即8bit×3-24bit，重新划分时6bit为一组，8和6的最小公倍数是24，24bit是3字节，故三个字节为一组时无需补位。" class="headerlink" title="若原始数据长度是3的倍数，即8bit×3&#x3D;24bit，重新划分时6bit为一组，8和6的最小公倍数是24，24bit是3字节，故三个字节为一组时无需补位。"></a><em>若原始数据长度是3的倍数，即8bit×3&#x3D;24bit，重新划分时6bit为一组，8和6的最小公倍数是24，24bit是3字节，故三个字节为一组时无需补位。</em></h6><p><img src="/../images/image-20250728092802343.png" alt="image-20250728092802343"></p>
<ul>
<li>若原始数据长度不是3的倍数：</li>
</ul>
<p><img src="/../images/image-20250728094644134.png" alt="image-20250728094644134"></p>
<p>三个一组，空位补0，所以base64编码后有**&#x3D;**。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>3个字节经过编码后，变成4个字节。<strong>编码后字串长度÷3×4</strong>。</p>
<h5 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h5><ul>
<li><p>末尾通常有<code>=</code>填充（最多2个），如<code>YWRtaW4=</code>。</p>
</li>
<li><p>若密文包含<code>+</code>或<code>/</code>且长度是4的倍数，优先考虑Base64。</p>
</li>
</ul>
<h4 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h4><h5 id="base64换表解密"><a href="#base64换表解密" class="headerlink" title="base64换表解密"></a>base64换表解密</h5><p>【ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;】是标准的base64加解密表，共64个字符，如果对标准表中的字符进行顺序替换，称之为base64换表。</p>
<p>对于换表base64，需要将换表的字符映射回标准表，然后再进行解密。</p>
<p>举例：</p>
<p>换表是【qvEJAfHmUYjBac+u8Ph5n9Od17FrICL&#x2F;X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD】</p>
<p>密文是【5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM&#x2F;8&#x3D;&#x3D;】</p>
<p>密文中第一个字符是5，在换表中的索引（下标）为19，而在标准表中，索引19处的字符为【’T’】</p>
<p>密文中第二个字符是M，在换表中的索引（下标）为37，而在标准表中，索引19处的字符为【’l’】</p>
<p>以此类推，完成映射。再用映射后的字符串，查找其ASCII码，再转换为6位二进制数，再解密还原。</p>
<h3 id="Base16"><a href="#Base16" class="headerlink" title="Base16"></a>Base16</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>base16编码也称为十六进制编码或Hex编码，是一种将二进制数据表示为十六进制数字和字符的方法。它使用**16个字符（0-9和A-F）**来表示4位二进制数的每个组合。</p>
<h4 id="编码步骤-1"><a href="#编码步骤-1" class="headerlink" title="编码步骤"></a>编码步骤</h4><p>将二进制数据4个一组，分别转换成对应base16字符。若不是4的倍数，就在末端补0。</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>因为1byte＝8bit，所以1byte &#x3D; 2个十六进制数。</p>
<p><em>4bit就可以表示2^4 &#x3D; 16个字符。所以用4bit可以表示所有的十六进制数。</em></p>
<h3 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Base32编码是一种将二进制数据转换为使用<strong>32个</strong>不同字符表示的文本编码方式</p>
<h4 id="编码步骤-2"><a href="#编码步骤-2" class="headerlink" title="编码步骤"></a>编码步骤</h4><p>将二进制数据5个一组，之后再根据base32索引表，进行编码。如果结尾不满足5的倍数，就用“&#x3D;”填充，</p>
<h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>由于5bit就可以表示2^5 &#x3D; 32个字符。所以5bit可以表示32个不同的字符。</p>
<h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>RC4加密是一种对称加密</p>
<h3 id="加密-解密-原理："><a href="#加密-解密-原理：" class="headerlink" title="加密(解密)原理："></a>加密(解密)原理：</h3><p><img src="/../images/image-20250729093831386.png" alt="image-20250729093831386"></p>
<p>密钥流和明文异或得到密文，密文和密钥流异或得到明文。</p>
<h4 id="几个关键变量"><a href="#几个关键变量" class="headerlink" title="几个关键变量"></a>几个关键变量</h4><p>1：S-Box（S盒），密钥流生成器。一个256长度的char型数组，每个单元都是一个字节。</p>
<p>3：密钥流keystream</p>
<h3 id="逆向中的运用"><a href="#逆向中的运用" class="headerlink" title="逆向中的运用"></a>逆向中的运用</h3><h5 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h5><p>三个for循环，前两个256 for 循环为准备工作。</p>
<p>第一个循环给s盒赋值，第二个循环根据密钥key对S盒进行交换。根据源码的了解，<strong>a2中保存的是密钥key</strong></p>
<p><img src="/../images/image-20250729115547043.png" alt="image-20250729115547043"></p>
<p>第三个循环是S盒的swap，明文和S盒的异或。其中v6为S盒，a2指向明文和密文。</p>
<p><img src="/../images/image-20250729162734525.png" alt="image-20250729162734525"></p>
<h5 id="魔改RC4"><a href="#魔改RC4" class="headerlink" title="魔改RC4"></a>魔改RC4</h5><p>多数赛题将rc4与其他算法进行组合来加密flag</p>
<h6 id="常见变化位置："><a href="#常见变化位置：" class="headerlink" title="常见变化位置："></a>常见变化位置：</h6><p>密钥经过上一步的其他加密后传入</p>
<p>s盒内部数据固定</p>
<p>rc4加密后数据进行重加密</p>
<h2 id="TEA加密"><a href="#TEA加密" class="headerlink" title="TEA加密"></a>TEA加密</h2><h3 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>TEA是一种分组加密算法。默认进行32轮加密</p>
<p>TEA加密解密是按8字节（64bit）为一组，密钥16字节（128bit）为一组。</p>
<p>该算法使用了常数δ（delta)作为倍数，保证每一轮加密都不相同。δ对应的数指是<strong>0×9E3779B9</strong>，这个值在TEA加密或者解密中会有用到。</p>
<h4 id="逆向中的运用-1"><a href="#逆向中的运用-1" class="headerlink" title="逆向中的运用"></a>逆向中的运用</h4><h5 id="算法特征-1"><a href="#算法特征-1" class="headerlink" title="算法特征"></a>算法特征</h5><p>tea算法的主要特征表现在sum和delta变量，以及3行核心加密中出现的<strong>右移4左移5</strong>，两行各有3个小括号互相异或</p>
<p>在题目中看到这些特征时就应该警醒这是tea相关算法</p>
<p>delta的值一般为0x9E3779B9(-0x61C88647)，但题目中往往会改变它的值（魔改，导致部分识别加密的工具失效），但并不影响算法的逆向。</p>
<p><img src="/../images/image-20250729174920462.png" alt="image-20250729174920462"></p>
<h3 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>XTEA是TEA的升级版，默认进行64轮加密</p>
<h5 id="与TEA的区别"><a href="#与TEA的区别" class="headerlink" title="与TEA的区别"></a>与TEA的区别</h5><p>之前取key的时候是固定下标取的,现在通过计算来取。</p>
<h4 id="算法特征-2"><a href="#算法特征-2" class="headerlink" title="算法特征"></a>算法特征</h4><p>key不是按固定下标取，而是通过计算。</p>
<p><img src="/../images/image-20250730093729374.png" alt="image-20250730093729374"></p>
<h3 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a>XXTEA</h3><h4 id="与TEA，XTEA的区别"><a href="#与TEA，XTEA的区别" class="headerlink" title="与TEA，XTEA的区别"></a>与TEA，XTEA的区别</h4><p>原字符串长度可以不是4的倍数。加密过程更复杂。</p>
<h2 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>AES即高级加密标准，为对称加密。</p>
<blockquote>
<p>对称加密：加密解密使用相同的密钥。</p>
</blockquote>
<p><img src="/../images/image-20250808112418793.png" alt="image-20250808112418793"></p>
<p>实际中，一般是通过RSA加密AES的密钥。</p>
<h4 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h4><p>AES为分组密码，在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同</p>
<blockquote>
<p>分组密码也就是把明文分成多组，每组长度相等，每次加密一组数据，直到加密完整个明文。</p>
</blockquote>
<p>（下图长度单位为字节）</p>
<p><img src="/../images/image-20250808132348639.png" alt="image-20250808132348639"></p>
<p>（以128位密钥为例）</p>
<p><img src="/../images/image-20250809132446555.png" alt="image-20250809132446555"></p>
<p>明文被排列成4*4的矩阵，排列顺序是从上到下从左到右。根据密钥长度进行加密后输出4*4&#x3D;16个字节的密文。</p>
<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p>AES加密过程包括以下步骤：</p>
<ol>
<li>字节代换：使用一个16x16的S盒进行字节替换。</li>
<li>行移位：对状态数组的行进行循环移位。</li>
<li>列混合：将状态数组的每一列与一个固定矩阵相乘。</li>
<li>轮密钥加：将状态数组与轮密钥进行异或操作。</li>
</ol>
<h3 id="分类——AES的五种加密形式"><a href="#分类——AES的五种加密形式" class="headerlink" title="分类——AES的五种加密形式"></a>分类——AES的五种加密形式</h3><h4 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h4><p>电码本模式。将整个明文分成若干段相同的小段，然后对每一小段进行加密。</p>
<h4 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h4><p>密码分组链接模式。将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</p>
<h4 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h4><p>计算器模式。 有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。</p>
<h4 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h4><h4 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h4><h3 id="逆向特征"><a href="#逆向特征" class="headerlink" title="逆向特征"></a>逆向特征</h3><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>MD5是MD5消息摘要算法的简称。可以产生出一个128位（16字节）的哈希值。</p>
<blockquote>
<p>哈希值：将任意长度的输入字符串通过哈希算法转换为固定长度的输出。</p>
</blockquote>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>校验文件是否发生了改变。（MD5值等同于文件的ID，它的值是<strong>唯一</strong>的。 如果文件已被修改（例如嵌入式病毒，特洛伊木马等），其MD5值将发生变化。）</p>
<h3 id="加密方法-1"><a href="#加密方法-1" class="headerlink" title="加密方法"></a>加密方法</h3><ol>
<li><p>在输入信息后填充1和无数个0，直到填充后其位长对<code>512求余</code>的<code>结果</code>为<code>448</code>。填充后的 “输入信息” 其位长 (Bits Length) 将扩展到：<code>N*512+448</code> ( N&gt;&#x3D;0 )</p>
</li>
<li><p>用<code>64bit</code>记录 “输入信息” 的位长 (Bits Length)，把64位长度二进制数据补在最后。经过此步骤后，其位长 (Bits Length) 将扩展到：<code>N*512+448+64 = (N+1)*512</code> ( N&gt;&#x3D;0 )</p>
</li>
<li><p>每一<code>512bit</code>又分为<code>16个</code>子分组，每个子分组为<code>32bit</code>的数据；<code>16</code>个子分组分别命名为 <code>M0~M15</code></p>
</li>
<li><p>每个子分组都要进行<code>4</code>次运算，运算公式分别为FF、GG、HH、II；总的运算次数为<code>N*16*4</code>（运算均为位<img src="/../images/4619b605fb432294e52452b1f725169b.png" alt="4619b605fb432294e52452b1f725169b"></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" data-id="cmgtk5wpd0003t4gchl576ip8" data-title="&#39;加密算法&#39;" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-arm汇编" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/arm%E6%B1%87%E7%BC%96/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T12:46:19.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/arm%E6%B1%87%E7%BC%96/">arm汇编</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40309666/article/details/136190638">万字长文带你由浅入深夯实ARM汇编基础——汇编指令及寻址方式最全梳理（附示例）！_arm 与指令-CSDN博客</a></p>
<p>一些补充解释：</p>
<h2 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h2><h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><h4 id="CPSR"><a href="#CPSR" class="headerlink" title="CPSR"></a>CPSR</h4><p>简介：</p>
<ul>
<li>全称：程序状态寄存器(current program status register)</li>
<li>用户级编程时用于存储条件码</li>
<li>任何处理器模式下被访问</li>
</ul>
<h4 id="SPSR"><a href="#SPSR" class="headerlink" title="SPSR"></a>SPSR</h4><p>简介：</p>
<ul>
<li>全称：程序状态保存寄存器（saved program status register）</li>
<li>每一种处理器模式下都有一个状态寄存器SPSR，用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。</li>
</ul>
<h3 id="PC：-程序计数器"><a href="#PC：-程序计数器" class="headerlink" title="PC： 程序计数器"></a>PC： 程序计数器</h3><p>这是一个特殊的寄存器，它保存着<strong>下一条将要被执行的指令的内存地址</strong>。改变PC的值，就等于让CPU跳转到新的地址去执行代码。</p>
<h3 id="LR：-链接寄存器"><a href="#LR：-链接寄存器" class="headerlink" title="LR： 链接寄存器"></a>LR： 链接寄存器</h3><p>这是一个专门用于存放<strong>函数返回地址</strong>的寄存器。</p>
<blockquote>
<p>所以MOV PC,LR表示子程序返回。</p>
</blockquote>
<h2 id="ARM中的操作数2详解"><a href="#ARM中的操作数2详解" class="headerlink" title="ARM中的操作数2详解"></a>ARM中的操作数2详解</h2><p>操作数可由12位组成，前四位我们称之为rot字段，后四位称为imm字段。</p>
<p>作用：用12位数据表示8，12，16，32等位数的数据。</p>
<h3 id="rot"><a href="#rot" class="headerlink" title="rot"></a>rot</h3><ul>
<li>它的值是 <code>0</code> 到 <code>15</code>。</li>
<li>实际循环右移位数 &#x3D; <code>rot × 2</code>。</li>
</ul>
<p><strong>为什么是 × 2？</strong></p>
<ul>
<li>为了<strong>节省这4位的空间</strong>。如果 <code>rot</code> 直接表示移位位数，只能表示0-15位。但乘以2后，可以表示 <strong>0, 2, 4, 6, …, 30</strong> 位，范围扩大了一倍。</li>
<li>因为移位位数是偶数，这确保了8位常数在32位寄存器中总是能对齐到<strong>字节边界</strong>，硬件实现更简单高效。</li>
</ul>
<h2 id="ARM指令"><a href="#ARM指令" class="headerlink" title="ARM指令"></a>ARM指令</h2><h3 id="Branch指令"><a href="#Branch指令" class="headerlink" title="Branch指令"></a>Branch指令</h3><p>Branch 指令顾名思义，就是“分支”指令。它让CPU不再局限于一条接一条地顺序执行指令，而是能够<strong>跳转</strong>到程序的其他位置继续执行。</p>
<h4 id="ARM中的主要Branch指令类型"><a href="#ARM中的主要Branch指令类型" class="headerlink" title="ARM中的主要Branch指令类型"></a>ARM中的主要Branch指令类型</h4><h5 id="B-Branch-无条件跳转"><a href="#B-Branch-无条件跳转" class="headerlink" title="B (Branch) - 无条件跳转"></a>B (Branch) - 无条件跳转</h5><p>它就像高级语言（如C语言）中的 <code>goto</code> 语句。</p>
<h5 id="BEQ-Branch-if-EQual-条件分支指令"><a href="#BEQ-Branch-if-EQual-条件分支指令" class="headerlink" title="BEQ(Branch if EQual) - 条件分支指令"></a>BEQ(Branch if EQual) - 条件分支指令</h5><p>它检查CPSR中的Z标志位。如果 <code>Z == 1</code>，则进行跳转；否则，不跳转，继续顺序执行下一条指令。</p>
<blockquote>
<p>当一条指令的执行结果产生了数值0，CPU就会将Z标志位设为1。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/arm%E6%B1%87%E7%BC%96/" data-id="cmgtk5wpd0002t4gccurk9jdh" data-title="arm汇编" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/16/Android-Java%E5%B1%82%E9%80%86%E5%90%91/">Android - Java层逆向</a>
          </li>
        
          <li>
            <a href="/2025/10/16/angr%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6/">angr分析框架</a>
          </li>
        
          <li>
            <a href="/2025/10/16/OLLVM%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/">OLLVM混淆与反混淆</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">&#39;加密算法&#39;</a>
          </li>
        
          <li>
            <a href="/2025/10/15/arm%E6%B1%87%E7%BC%96/">arm汇编</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>